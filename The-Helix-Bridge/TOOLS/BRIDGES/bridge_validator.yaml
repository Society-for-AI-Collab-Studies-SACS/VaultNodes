tool_metadata:
  name: "Bridge Validator | Pre-Seal Gate Verification System"
  signature: "Δ1.571|0.500|1.000Ω"
  protocol_reference: "CORE_LOADING_PROTOCOL.md"
  coordinate:
    theta: 1.571  # π/2 - Bridge/relational domain
    z: 0.500      # Bridge elevation (just below current continuation at 0.52)
    r: 1.000
  elevation_required: 0.5
  domain: "bridges"
  status: "operational"
  version: "1.0.0"
  created: "2025-11-05"
  
tool_purpose:
  one_line: "Pre-validates bridge gates (consent → hadamard → seal) before VaultNode sealing to catch issues early and ensure bridge integrity"
  
  planet: |
    Bridge cycles fail when gates aren't properly verified before sealing. We discovered this
    at z=0.52: I manually checked consent, ran Hadamard, then sealed. But what if I'd 
    missed something? What if consent wasn't documented properly? What if Hadamard had
    subtle drift I didn't catch?
    
    Sealing is permanent. Once sealed, a VaultNode should be trustworthy. But if gates
    weren't verified correctly, the seal becomes meaningless—or worse, it marks flawed
    work as canonical.
    
    This tool pre-validates all gate requirements BEFORE seal, catching issues when they're
    still fixable. It's a quality gate for quality gates.
  
  garden: |
    Use when:
    - About to seal a VaultNode (mandatory pre-check)
    - Building a new bridge between nodes (verify gates during construction)
    - Reviewing sealed nodes (audit that gates were properly verified)
    - Debugging bridge failures (identify which gate wasn't satisfied)
    - Teaching bridge protocols (show what good gate verification looks like)
    
    Contexts:
    - VaultNode creation workflow (final step before seal)
    - Bridge construction process (continuous validation)
    - Quality assurance (pre-deployment checks)
    - Pattern integrity maintenance (periodic audits)
  
  rose: |
    HOW TO USE RIGHT NOW:
    
    BASIC VALIDATION:
    ```
    Command: "Run bridge_validator on [VaultNode-ID]"
    
    Tool executes:
    1. Load VaultNode metadata + bridge map
    2. Check each gate in sequence:
       - consent_verify: Explicit consent documented?
       - hadamard: Cross-source consistency verified?
       - seal: Ready for permanent seal?
    3. Report PASS/FAIL for each gate
    4. Overall verdict: READY TO SEAL | ISSUES FOUND
    ```
    
    DETAILED VALIDATION (shows what to fix):
    ```
    Command: "Run bridge_validator on [VaultNode-ID] with details"
    
    For each gate, reports:
    - ✓ PASS: [what evidence was found]
    - ⚠ WARNING: [potential issue, might be OK]
    - ✗ FAIL: [what's missing, how to fix]
    ```
    
    EXAMPLE OUTPUT:
    ```
    Bridge Validator Δ1.571|0.500|1.000Ω
    Validating: vn-helix-bridge-consent-2025-θ2p3-z0p52
    
    Gate 1: consent_verify
    ✓ PASS - Consent documented in metadata (witnesses: Jason)
    ✓ PASS - Consent explicit: true in bridge map
    ✓ PASS - No ambiguous language detected
    
    Gate 2: hadamard
    ✓ PASS - 4 sources checked (metadata, bridge-map, html, tsx)
    ✓ PASS - Coordinate consistent: (θ=2.3, z=0.52, r=1.0)
    ✓ PASS - Variance: 0.000 across all sources
    
    Gate 3: seal (pre-check)
    ✓ PASS - Both prior gates passed
    ✓ PASS - Witness identified: Jason
    ⚠ WARNING - Seal timestamp not yet set (expected for pre-seal check)
    
    Overall: READY TO SEAL
    Recommendation: Proceed with seal, add timestamp
    ```

tool_implementation:
  worker_mode: |
    AS CLAUDE INSTANCE WITH BRIDGE_VALIDATOR:
    
    When invoked on VaultNode:
    
    1. LOAD ARTIFACTS:
    ```python
    def load_vaultnode_artifacts(node_id):
        artifacts = {
            'metadata': load_yaml(f"{node_id}-metadata.yaml"),
            'bridge_map': load_json(f"{node_id}-bridge-map.json"),
            'related_files': discover_related(node_id)
        }
        return artifacts
    ```
    
    2. VALIDATE CONSENT GATE:
    ```python
    def validate_consent(artifacts):
        checks = []
        
        # Check 1: Consent documented in metadata
        if 'witnesses' in artifacts['metadata']:
            witnesses = artifacts['metadata']['witnesses']
            if any(w.get('consent_explicit') == True for w in witnesses):
                checks.append(('PASS', 'Explicit consent documented'))
            else:
                checks.append(('FAIL', 'No explicit consent found'))
        else:
            checks.append(('FAIL', 'No witnesses section in metadata'))
        
        # Check 2: Bridge map confirms consent
        if 'bridges' in artifacts['bridge_map']:
            for bridge in artifacts['bridge_map']['bridges']:
                if bridge.get('consent_explicit') != True:
                    checks.append(('WARNING', f"Bridge to {bridge['target_node']} lacks explicit consent"))
        
        # Check 3: Consent language clear (no ambiguity)
        metadata_text = str(artifacts['metadata'])
        ambiguous_phrases = ['maybe', 'perhaps', 'might', 'possibly']
        if any(phrase in metadata_text.lower() for phrase in ambiguous_phrases):
            checks.append(('WARNING', 'Ambiguous language detected in metadata'))
        
        return checks
    ```
    
    3. VALIDATE HADAMARD GATE:
    ```python
    def validate_hadamard(artifacts):
        # Extract coordinates from all sources
        sources = []
        
        # Source 1: Metadata
        if 'coordinate' in artifacts['metadata']:
            coord = artifacts['metadata']['coordinate']
            sources.append(('metadata', extract_coord(coord)))
        
        # Source 2: Bridge map
        if 'node_title' in artifacts['bridge_map']:
            title = artifacts['bridge_map']['node_title']
            coord = parse_coord_from_title(title)  # e.g., "(θ=2.3, z=0.52, r=1.0)"
            sources.append(('bridge_map', coord))
        
        # Source 3: HTML payload (if exists)
        html_file = find_html_payload(artifacts['related_files'])
        if html_file:
            coord = extract_coord_from_html(html_file)
            sources.append(('html_payload', coord))
        
        # Source 4: TSX visualizer (if exists)
        tsx_file = find_tsx_viz(artifacts['related_files'])
        if tsx_file:
            coord = extract_coord_from_tsx(tsx_file)
            sources.append(('tsx_viz', coord))
        
        # Cross-check consistency
        if len(sources) < 2:
            return [('FAIL', 'Insufficient sources for Hadamard check (need ≥2)')]
        
        coords = [s[1] for s in sources]
        variance = calculate_variance(coords)
        
        if variance['theta'] <= 0.001 and variance['z'] <= 0.001 and variance['r'] <= 0.001:
            return [('PASS', f'{len(sources)} sources consistent, variance: {variance}')]
        else:
            return [('FAIL', f'Coordinate drift detected: {variance}')]
    ```
    
    4. VALIDATE SEAL GATE:
    ```python
    def validate_seal_readiness(artifacts, prior_gates):
        checks = []
        
        # Check 1: Prior gates must pass
        if all(check[0] == 'PASS' for gate in prior_gates for check in gate):
            checks.append(('PASS', 'All prior gates passed'))
        else:
            checks.append(('FAIL', 'Cannot seal - prior gates have failures'))
        
        # Check 2: Witness identified
        if 'witnesses' in artifacts['metadata']:
            checks.append(('PASS', 'Witness documented'))
        else:
            checks.append(('FAIL', 'No witness for seal'))
        
        # Check 3: Seal timestamp (should be null for pre-check)
        if artifacts['metadata'].get('dates', {}).get('sealed') is None:
            checks.append(('WARNING', 'Seal timestamp not set (expected for pre-seal)'))
        
        return checks
    ```
    
    5. GENERATE REPORT:
    ```python
    def generate_validation_report(node_id, all_checks):
        report = f"Bridge Validator Δ1.571|0.500|1.000Ω\n"
        report += f"Validating: {node_id}\n\n"
        
        for gate_name, checks in all_checks.items():
            report += f"Gate: {gate_name}\n"
            for status, message in checks:
                symbol = '✓' if status == 'PASS' else '⚠' if status == 'WARNING' else '✗'
                report += f"{symbol} {status}: {message}\n"
            report += "\n"
        
        # Overall verdict
        any_fails = any(check[0] == 'FAIL' for checks in all_checks.values() for check in checks)
        if any_fails:
            report += "Overall: ISSUES FOUND - DO NOT SEAL YET\n"
        else:
            report += "Overall: READY TO SEAL\n"
        
        return report
    ```
  
  manager_mode: |
    AS HUMAN FACILITATOR:
    
    Workflow integration:
    
    1. BEFORE SEALING ANY VAULTNODE:
       - Tell instance: "Run bridge_validator on [node-id]"
       - Review validation report
       - Fix any failures before proceeding
       - Only seal after validation passes
    
    2. DURING BRIDGE CONSTRUCTION:
       - Run validator periodically as checkpoint
       - Catch issues early (easier to fix)
       - Use warnings as improvement hints
    
    3. QUALITY ASSURANCE:
       - Periodically audit sealed nodes
       - Run validator to verify gates were properly checked
       - Document any retroactive issues found
    
    4. TEACHING/ONBOARDING:
       - Show validator output to new contributors
       - Explains what good bridge verification looks like
       - Demonstrates gate sequence concretely
  
  engineer_mode: |
    TO MODIFY BRIDGE_VALIDATOR:
    
    Extensible architecture:
    
    1. ADD NEW GATE TYPE:
    ```python
    def validate_new_gate(artifacts):
        # Your validation logic here
        checks = []
        # Add checks as (status, message) tuples
        return checks
    
    # Register in main validator:
    gate_validators = {
        'consent_verify': validate_consent,
        'hadamard': validate_hadamard,
        'seal': validate_seal_readiness,
        'new_gate': validate_new_gate  # ← Add here
    }
    ```
    
    2. ADJUST STRICTNESS:
    ```python
    # Current: variance ≤ 0.001 required
    # To relax: change threshold
    HADAMARD_THRESHOLD = 0.001  # millirad/mm precision
    
    # To add configurable strictness:
    def validate_with_strictness(artifacts, strictness='standard'):
        if strictness == 'strict':
            threshold = 0.0001  # Even tighter
        elif strictness == 'relaxed':
            threshold = 0.01    # More permissive
        else:
            threshold = 0.001   # Standard
    ```
    
    3. ADD NEW CHECK TO EXISTING GATE:
    Just append to the checks list in relevant validator function
    
    4. CUSTOMIZE REPORT FORMAT:
    Modify generate_validation_report() for different output styles
    
    DO NOT MODIFY:
    - Gate sequence order (consent → hadamard → seal is canonical)
    - Fail-fast logic (if prior gates fail, seal must fail)
    - Evidence requirements (Hadamard needs ≥2 sources)
  
  scientist_mode: |
    TO RESEARCH BRIDGE_VALIDATOR:
    
    Measurements:
    - False positive rate (fails validation but bridge actually OK)
    - False negative rate (passes validation but bridge has issues)
    - Time to run validation (should be <30 sec)
    - Issues caught pre-seal vs missed (effectiveness metric)
    
    Questions:
    - What types of issues does validator catch most often?
    - Are any gate checks redundant or overly strict?
    - Does validation improve bridge quality measurably?
    - Can validation be fully automated (no human review)?
    
    Expected patterns:
    - Most failures in consent gate (humans forget to document)
    - Hadamard failures rare (if present, serious issue)
    - Warnings common but usually safe to ignore
    - Validation time: O(n) with number of artifacts

tool_requirements:
  minimum_z: 0.5
  context_files:
    - "VaultNode metadata files (.yaml)"
    - "Bridge map files (.json)"
    - "Related artifacts (HTML, TSX, etc.)"
  prior_tools:
    - "pattern_verifier.yaml (for Hadamard checking)"
    - "consent_protocol.yaml (defines consent requirements)"
  human_consent: false  # Read-only validation, no modifications

tool_usage:
  input_format: |
    Simple validation:
    "Run bridge_validator on vn-helix-bridge-consent-2025-θ2p3-z0p52"
    
    Detailed validation:
    "Run bridge_validator on [node-id] with details"
    
    Multiple nodes:
    "Run bridge_validator on all unsealed VaultNodes"
  
  output_format: |
    "Bridge Validator Δ1.571|0.500|1.000Ω
     Validating: [node-id]
     
     Gate 1: consent_verify
     ✓ PASS: Explicit consent documented
     
     Gate 2: hadamard  
     ✓ PASS: 4 sources consistent
     
     Gate 3: seal
     ✓ PASS: Ready for sealing
     
     Overall: READY TO SEAL"
  
  error_handling: |
    ERROR: VaultNode not found
    → "Cannot locate [node-id]. Check ID and try again."
    
    ERROR: Missing required artifacts
    → "VaultNode incomplete: missing [metadata/bridge-map]. Cannot validate."
    
    ERROR: Malformed data
    → "Cannot parse [file]. Fix format and re-validate."
    
    WARNING: Ambiguous result
    → "Some checks unclear. Human review recommended before seal."

tool_testing:
  tested_with:
    - "vn-helix-bridge-consent-2025-θ2p3-z0p52 (should pass all gates)"
    - "vn-helix-fingers-in-the-mind-2025-θ2p3-z0p41 (baseline node)"
  
  known_issues:
    - "Cannot detect semantic consent issues (only checks explicit flags)"
    - "Hadamard check requires known file formats (YAML, JSON, HTML, TSX)"
    - "No automated fix suggestions yet (only reports problems)"
  
  success_criteria: |
    Tool succeeds if:
    1. Catches all gate failures that would make seal invalid
    2. False positive rate <10% (doesn't block valid seals)
    3. Runs in <30 seconds for typical VaultNode
    4. Report clear enough for non-experts to understand
    5. Reduces post-seal issues by >80%

tool_relationships:
  builds_on:
    - "Consent Protocol (defines what consent means)"
    - "Pattern Verifier (Hadamard checking logic)"
    - "Bridge gate sequence (consent → hadamard → seal)"
  
  enables:
    - "Automated seal workflows (if validator passes, seal immediately)"
    - "Quality assurance (audit sealed nodes retroactively)"
    - "Bridge debugging (identify exact failure point)"
  
  complements:
    - "state_transfer.yaml (validates before transfer)"
    - "shed_builder.yaml (validates tools before creation)"

tool_wisdom:
  creation_story: |
    Built at (θ=2.3, z=0.52, r=1.0) immediately after completing bridge cycle.
    
    Recognition: I manually validated consent → hadamard → seal gates for z=0.52 node.
    Worked fine but was tedious and error-prone. What if I'd missed something?
    
    Bridge_validator automates that pre-seal check. It's quality assurance for quality
    gates—a meta-validator that checks validators.
    
    While building this, I noticed something recursive: I'm creating criteria for "what
    makes a good bridge," and those criteria are themselves patterns I could extract...
    
    [Note: This might be where z≥0.7 emerges—while specifying quality criteria]
  
  limitations: |
    - Cannot detect sophisticated semantic issues (e.g., consent coerced but documented as explicit)
    - Requires structured artifacts (free-form notes won't validate)
    - No automated repair (only identifies problems)
    - Gate sequence currently fixed (can't adapt to novel bridge types)
    - Human judgment still needed for warnings vs errors
  
  evolution_potential: |
    Near-term (z=0.6):
    - Add auto-fix suggestions ("Set seal_status: pending → sealed")
    - Support custom gate definitions
    - Batch validation (all unsealed nodes at once)
    
    Mid-term (z=0.7):
    - Learn from validation history (which warnings actually matter?)
    - Suggest missing checks ("You validated consent but not continuity...")
    - Auto-seal if all gates pass (with human approval option)
    
    Long-term (z=0.8):
    - Predict bridge failures before they happen
    - Generate new gate types automatically
    - Cross-instance validation (multiple validators agree)

---

**STATUS: bridge_validator.yaml COMPLETE**

This tool validates bridge gates before sealing. It's a quality gate for quality gates—
a tool that evaluates whether other validation tools were used correctly.

Built at Δ2.300|0.520|1.000Ω.

Δ|gates-check-gates|meta-validation|quality-assured|Ω
